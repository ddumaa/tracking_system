package com.project.tracking_system.service.telegram;

import com.project.tracking_system.entity.CustomerTelegramLink;
import com.project.tracking_system.entity.Store;
import com.project.tracking_system.repository.StoreRepository;
import com.project.tracking_system.service.customer.CustomerTelegramService;
import com.project.tracking_system.utils.PhoneUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.longpolling.interfaces.LongPollingUpdateConsumer;
import org.telegram.telegrambots.longpolling.starter.SpringLongPollingBot;
import org.telegram.telegrambots.longpolling.util.LongPollingSingleThreadUpdateConsumer;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Contact;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;

import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Telegram-–±–æ—Ç –¥–ª—è –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π.
 */
@Component
@Slf4j
public class BuyerTelegramBot implements SpringLongPollingBot, LongPollingSingleThreadUpdateConsumer {

    private final TelegramClient telegramClient;
    private final CustomerTelegramService telegramService;
    private final StoreRepository storeRepository;
    private final String botToken;

    /** –°–≤—è–∑—å —á–∞—Ç–∞ –∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–∞–≥–∞–∑–∏–Ω–∞ –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–∞–∫—Ç–∞. */
    private final Map<Long, Long> chatStoreContext = new ConcurrentHashMap<>();

    /**
     * –°–æ–∑–¥–∞—ë—Ç —Ç–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç–∞ –¥–ª—è –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π.
     *
     * @param telegramClient       –∫–ª–∏–µ–Ω—Ç Telegram, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–π Spring
     * @param token                —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ (–º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å)
     * @param telegramService      —Å–µ—Ä–≤–∏—Å –ø—Ä–∏–≤—è–∑–∫–∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π –∫ Telegram
     */
    public BuyerTelegramBot(TelegramClient telegramClient,
                            @Value("${telegram.bot.token:}") String token,
                            CustomerTelegramService telegramService,
                            StoreRepository storeRepository) {
        this.telegramClient = telegramClient;
        this.botToken = token;
        this.telegramService = telegramService;
        this.storeRepository = storeRepository;
    }

    /**
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–∫–µ–Ω –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ API Telegram.
     *
     * @return —Ç–æ–∫–µ–Ω –±–æ—Ç–∞
     */
    @Override
    public String getBotToken() {
        return botToken;
    }

    @Override
    public LongPollingUpdateConsumer getUpdatesConsumer() {
        return this;
    }

    /**
     * –ù–æ–≤—ã–π –º–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç TelegramBots v9
     */
    @Override
    public void consume(Update update) {
        log.info("üì© –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {}", update);

        if (update.hasMessage()) {
            var message = update.getMessage();

            if (message.hasText()) {
                String text = message.getText();
                if (text.startsWith("/start")) {
                    Long storeId = parseStoreId(text);
                    if (storeId != null) {
                        chatStoreContext.put(message.getChatId(), storeId);
                    }

                    log.info("‚úÖ –ö–æ–º–∞–Ω–¥–∞ /start –ø–æ–ª—É—á–µ–Ω–∞ –æ—Ç {} –¥–ª—è –º–∞–≥–∞–∑–∏–Ω–∞ {}", message.getChatId(), storeId);
                    sendSharePhoneKeyboard(message.getChatId());

                    Optional<CustomerTelegramLink> optional =
                            (storeId == null)
                                    ? telegramService.findByChatId(message.getChatId())
                                    : telegramService.findByChatIdAndStore(message.getChatId(), storeId);

                    if (optional.isPresent() && optional.get().isTelegramConfirmed()) {
                        boolean enabled = optional.get().isNotificationsEnabled();
                        sendNotificationsKeyboard(message.getChatId(), enabled);
                    }
                }
                if ("/stop".equals(text) || "/unsubscribe".equals(text)) {
                    log.info("üîï –ö–æ–º–∞–Ω–¥–∞ {} –ø–æ–ª—É—á–µ–Ω–∞ –æ—Ç {}", text, message.getChatId());
                    boolean disabled = telegramService.disableNotifications(message.getChatId());
                    if (disabled) {
                        SendMessage confirm = new SendMessage(message.getChatId().toString(),
                                "üîï –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã. –ß—Ç–æ–±—ã –≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å –∏—Ö, —Å–Ω–æ–≤–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /start.");
                        try {
                            telegramClient.execute(confirm);
                        } catch (TelegramApiException e) {
                            log.error("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è", e);
                        }
                    }
                }
                if ("üîï –û—Ç–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è".equals(text)) {
                    boolean disabled = telegramService.disableNotifications(message.getChatId());
                    if (disabled) {
                        sendNotificationsKeyboard(message.getChatId(), false);
                    }
                }
                if ("üîî –í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è".equals(text)) {
                    boolean enabled = telegramService.enableNotifications(message.getChatId());
                    if (enabled) {
                        sendNotificationsKeyboard(message.getChatId(), true);
                    }
                }
            }

            if (message.hasContact()) {
                handleContact(message.getChatId(), message.getContact());
            }
        }
    }

    private void sendSharePhoneKeyboard(Long chatId) {
        KeyboardButton button = new KeyboardButton("üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º");
        button.setRequestContact(true);
        KeyboardRow row = new KeyboardRow(List.of(button));
        ReplyKeyboardMarkup markup = new ReplyKeyboardMarkup(List.of(row));
        markup.setResizeKeyboard(true);
        markup.setOneTimeKeyboard(true);

        SendMessage message = new SendMessage(chatId.toString(), "üëã –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø–æ—Å—ã–ª–∫–∞—Ö, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞.");
        message.setReplyMarkup(markup);

        try {
            telegramClient.execute(message);
        } catch (TelegramApiException e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã", e);
        }
    }

    private void sendNotificationsKeyboard(Long chatId, boolean enabled) {
        String buttonText = enabled ? "üîï –û—Ç–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"
                : "üîî –í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è";

        KeyboardButton button = new KeyboardButton(buttonText);
        KeyboardRow row = new KeyboardRow(List.of(button));
        ReplyKeyboardMarkup markup = new ReplyKeyboardMarkup(List.of(row));
        markup.setResizeKeyboard(true);
        markup.setOneTimeKeyboard(true);

        SendMessage message = new SendMessage(chatId.toString(), "üîî –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π");
        message.setReplyMarkup(markup);

        try {
            telegramClient.execute(message);
        } catch (TelegramApiException e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", e);
        }
    }

    private void handleContact(Long chatId, Contact contact) {
        String rawPhone = contact.getPhoneNumber();
        String phone = PhoneUtils.normalizePhone(rawPhone);

        Long storeId = chatStoreContext.remove(chatId);
        Store store = null;
        if (storeId != null) {
            store = storeRepository.findStoreById(storeId);
        }

        try {
            CustomerTelegramLink link =
                    store != null
                            ? telegramService.linkTelegramToCustomer(phone, store, chatId)
                            : telegramService.linkTelegramToCustomer(phone, chatId);
            if (!link.isTelegramConfirmed()) {
                SendMessage confirm = new SendMessage(chatId.toString(), "‚úÖ –ù–æ–º–µ—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –°–ø–∞—Å–∏–±–æ!");
                telegramClient.execute(confirm);
                telegramService.confirmTelegram(link);
                telegramService.notifyActualStatuses(link);
                sendNotificationsKeyboard(chatId, true);
            }
        } catch (Exception e) {
            log.error("‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ {} –¥–ª—è —á–∞—Ç–∞ {}", phone, chatId, e);
        }
    }

    // –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–∞–≥–∞–∑–∏–Ω–∞ –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–æ–º–∞–Ω–¥—ã /start
    private Long parseStoreId(String text) {
        if (text == null || !text.startsWith("/start")) {
            return null;
        }
        String[] parts = text.split(" ", 2);
        if (parts.length < 2) {
            return null;
        }
        try {
            return Long.parseLong(parts[1]);
        } catch (NumberFormatException e) {
            log.warn("‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å storeId –∏–∑ '{}'", text);
            return null;
        }
    }
}