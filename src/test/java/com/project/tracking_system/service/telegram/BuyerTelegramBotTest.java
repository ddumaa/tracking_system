package com.project.tracking_system.service.telegram;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.project.tracking_system.entity.AdminNotification;
import com.project.tracking_system.entity.BuyerBotScreen;
import com.project.tracking_system.entity.BuyerChatState;
import com.project.tracking_system.entity.Customer;
import com.project.tracking_system.entity.NameSource;
import com.project.tracking_system.service.admin.AdminNotificationService;
import com.project.tracking_system.service.customer.CustomerTelegramService;
import com.project.tracking_system.utils.PhoneUtils;
import com.project.tracking_system.service.telegram.support.InMemoryChatSessionRepository;
import com.project.tracking_system.service.telegram.ChatSession;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.EditMessageText;
import org.telegram.telegrambots.meta.api.objects.Chat;
import org.telegram.telegrambots.meta.api.objects.Contact;
import org.telegram.telegrambots.meta.api.objects.User;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboard;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardButton;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardRow;
import org.telegram.telegrambots.meta.api.objects.chatmember.ChatMemberUpdated;
import org.telegram.telegrambots.meta.generics.TelegramClient;

import java.time.ZonedDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * –¢–µ—Å—Ç—ã –¥–ª—è {@link BuyerTelegramBot}, –ø—Ä–æ–≤–µ—Ä—è—é—â–∏–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞.
 */
@ExtendWith(MockitoExtension.class)
class BuyerTelegramBotTest {

    private static final String MENU_BUTTON_TEXT = "üè† –ú–µ–Ω—é";

    @Mock
    private TelegramClient telegramClient;

    @Mock
    private CustomerTelegramService telegramService;

    @Mock
    private AdminNotificationService adminNotificationService;

    private BuyerTelegramBot bot;
    private FullNameValidator fullNameValidator;
    private InMemoryChatSessionRepository chatSessionRepository;
    private ObjectMapper objectMapper;
    private AtomicInteger messageIdSequence;

    /**
     * –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –∏ —Å—Ç–∞–± –ø–æ–¥ –∫–ª–∏–µ–Ω—Ç–∞ Telegram –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º.
     */
    @BeforeEach
    void setUp() {
        fullNameValidator = new FullNameValidator();
        chatSessionRepository = new InMemoryChatSessionRepository();
        objectMapper = new ObjectMapper();
        messageIdSequence = new AtomicInteger(100);
        bot = new BuyerTelegramBot(telegramClient, "token", telegramService, adminNotificationService,
                fullNameValidator, chatSessionRepository, objectMapper);
        doAnswer(invocation -> {
            Message response = new Message();
            response.setMessageId(messageIdSequence.getAndIncrement());
            return response;
        }).when(telegramClient).execute(any(SendMessage.class));
        when(telegramClient.execute(any(EditMessageText.class))).thenReturn(null);
        when(adminNotificationService.findActiveNotification()).thenReturn(Optional.empty());
        when(telegramService.findByChatId(anyLong())).thenReturn(Optional.empty());
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –Ω–æ–º–µ—Ä–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è –∏ –º–∞—Å–∫–∏—Ä—É—é—Ç—Å—è.
     *
     * @param input        –∏—Å—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
     * @param expectedMask –æ–∂–∏–¥–∞–µ–º–æ–µ –º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
     */
    @ParameterizedTest
    @MethodSource("recognizedPhones")
    void shouldRecognizePhoneFormatsWhenAwaiting(String input, String expectedMask) throws Exception {
        Long chatId = 123L;
        markAwaitingContact(chatId);

        Update update = mockTextUpdate(chatId, input);

        bot.consume(update);

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient).execute(captor.capture());
        SendMessage message = captor.getValue();

        assertEquals(chatId.toString(), message.getChatId());
        assertTrue(message.getText().contains(expectedMask));
        assertPhoneKeyboard(message.getReplyMarkup());
        verify(telegramService).findByChatId(chatId);
        verify(telegramService).updateLastActive(chatId);
        verifyNoMoreInteractions(telegramService);
    }

    /**
     * –£–±–µ–∂–¥–∞–µ—Ç—Å—è, —á—Ç–æ –ø—Ä–∏ –Ω–µ—Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–µ –≤—ã–≤–æ–¥—è—Ç—Å—è –ø–æ–¥—Å–∫–∞–∑–∫–∏ —Å —Ñ–æ—Ä–º–∞—Ç–∞–º–∏ –Ω–æ–º–µ—Ä–∞.
     */
    @Test
    void shouldShowFormatHintForUnrecognizedPhone() throws Exception {
        Long chatId = 456L;
        markAwaitingContact(chatId);

        Update update = mockTextUpdate(chatId, "random text");

        bot.consume(update);

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient).execute(captor.capture());
        SendMessage message = captor.getValue();

        assertEquals(chatId.toString(), message.getChatId());
        assertTrue(message.getText().contains("+375"));
        assertTrue(message.getText().contains("8029"));
        assertPhoneKeyboard(message.getReplyMarkup());
        verify(telegramService).findByChatId(chatId);
        verify(telegramService).updateLastActive(chatId);
        verifyNoMoreInteractions(telegramService);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /start –±–æ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –∑–∞–ø—Ä–æ—Å–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞.
     */
    @Test
    void shouldShowPhoneKeyboardOnStartWhenCustomerMissing() throws Exception {
        Long chatId = 321L;
        when(telegramService.findByChatId(chatId)).thenReturn(Optional.empty());

        Update update = mockTextUpdate(chatId, "/start");

        bot.consume(update);

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient).execute(captor.capture());
        SendMessage message = captor.getValue();

        assertEquals(chatId.toString(), message.getChatId());
        assertPhoneKeyboard(message.getReplyMarkup());
        assertTrue(message.getText().contains("–ø–æ–¥–µ–ª–∏—Ç–µ—Å—å"),
                "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Å—å–±—É –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø—Ä–∏ –∞–∫—Ç–∏–≤–Ω–æ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–∏ –±–∞–Ω–Ω–µ—Ä –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –ø–æ–≤–µ—Ä—Ö –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é.
     */
    @Test
    void shouldRenderActiveAnnouncementInMenu() throws Exception {
        Long chatId = 777L;
        Customer customer = new Customer();
        customer.setTelegramChatId(chatId);
        customer.setNotificationsEnabled(true);
        customer.setFullName("–ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤");
        customer.setNameSource(NameSource.USER_CONFIRMED);
        customer.setLastActiveAt(ZonedDateTime.now().minusHours(2));

        when(telegramService.findByChatId(chatId)).thenReturn(Optional.of(customer));

        AdminNotification notification = new AdminNotification();
        notification.setId(42L);
        notification.setTitle("–ù–æ–≤–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ");
        notification.setBodyLines(List.of("–ü–µ—Ä–≤—ã–π –ø—É–Ω–∫—Ç", "–í—Ç–æ—Ä–æ–π –ø—É–Ω–∫—Ç"));
        notification.setUpdatedAt(ZonedDateTime.now().minusMinutes(5));
        when(adminNotificationService.findActiveNotification()).thenReturn(Optional.of(notification));

        bot.consume(mockTextUpdate(chatId, "/start"));

        ArgumentCaptor<EditMessageText> editCaptor = ArgumentCaptor.forClass(EditMessageText.class);
        verify(telegramClient, atLeastOnce()).execute(editCaptor.capture());
        EditMessageText bannerEdit = editCaptor.getAllValues().get(editCaptor.getAllValues().size() - 1);

        assertTrue(bannerEdit.getText().contains(notification.getTitle()),
                "–¢–µ–∫—Å—Ç –±–∞–Ω–Ω–µ—Ä–∞ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏—è");
        assertTrue(bannerEdit.getText().contains("–ü–µ—Ä–≤—ã–π –ø—É–Ω–∫—Ç"));
        assertTrue(bannerEdit.getText().contains("–í—Ç–æ—Ä–æ–π –ø—É–Ω–∫—Ç"));

        assertNotNull(bannerEdit.getReplyMarkup(), "–û–∂–∏–¥–∞–ª–∞—Å—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –±–∞–Ω–Ω–µ—Ä–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏—è");
        assertTrue(bannerEdit.getReplyMarkup() instanceof InlineKeyboardMarkup,
                "–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ç–∏–ø–∞ InlineKeyboardMarkup");
        InlineKeyboardMarkup markup = (InlineKeyboardMarkup) bannerEdit.getReplyMarkup();
        InlineKeyboardButton okButton = markup.getKeyboard().get(0).get(0);
        assertEquals("–û–∫", okButton.getText(), "–ö–Ω–æ–ø–∫–∞ –±–∞–Ω–Ω–µ—Ä–∞ –¥–æ–ª–∂–Ω–∞ –Ω–∞–∑—ã–≤–∞—Ç—å—Å—è ¬´–û–∫¬ª");
        assertEquals("announcement:ack", okButton.getCallbackData());

        ChatSession session = chatSessionRepository.find(chatId)
                .orElseThrow(() -> new AssertionError("–°–µ—Å—Å–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞"));
        assertEquals(notification.getId(), session.getCurrentNotificationId(),
                "–í —Å–µ—Å—Å–∏–∏ –¥–æ–ª–∂–µ–Ω —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –æ–±—ä—è–≤–ª–µ–Ω–∏—è");
        assertFalse(session.isAnnouncementSeen(),
                "–ü–µ—Ä–µ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å—Å—è –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–º");
    }

    /**
     * –£–±–µ–∂–¥–∞–µ—Ç—Å—è, —á—Ç–æ –Ω–æ–≤—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –±–∞–Ω–Ω–µ—Ä –æ–±—ä—è–≤–ª–µ–Ω–∏—è –¥–æ –ø—Ä–∏–≤—è–∑–∫–∏.
     */
    @Test
    void shouldNotShowAnnouncementForNewUser() throws Exception {
        Long chatId = 888L;

        AdminNotification notification = new AdminNotification();
        notification.setId(55L);
        notification.setTitle("–û–±—ä—è–≤–ª–µ–Ω–∏–µ");
        notification.setBodyLines(List.of("–í–∞–∂–Ω–æ"));
        notification.setUpdatedAt(ZonedDateTime.now());
        when(adminNotificationService.findActiveNotification()).thenReturn(Optional.of(notification));
        when(telegramService.findByChatId(chatId)).thenReturn(Optional.empty());

        bot.consume(mockTextUpdate(chatId, "/start"));

        verify(telegramClient, never()).execute(any(EditMessageText.class));

        verify(telegramService).findByChatId(chatId);
        verify(telegramService).updateLastActive(chatId);
        verifyNoMoreInteractions(telegramService);
    }

    /**
     * –£–±–µ–∂–¥–∞–µ—Ç—Å—è, —á—Ç–æ –ø—Ä–∏ –ª—é–±–æ–π —Å–ª–µ—à-–∫–æ–º–∞–Ω–¥–µ –≤ –æ–∂–∏–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞ –±–æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É.
     */
    @Test
    void shouldRepeatContactRequestForSlashCommandWhileAwaitingContact() throws Exception {
        Long chatId = 322L;
        markAwaitingContact(chatId);

        Update update = mockTextUpdate(chatId, "/stats");

        bot.consume(update);

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient).execute(captor.capture());
        SendMessage message = captor.getValue();

        assertEquals(chatId.toString(), message.getChatId());
        assertPhoneKeyboard(message.getReplyMarkup());
        assertTrue(message.getText().contains("–∫–Ω–æ–ø–∫"),
                "–ë–æ—Ç –¥–æ–ª–∂–µ–Ω –Ω–∞–ø–æ–º–Ω–∏—Ç—å –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∫–Ω–æ–ø–∫–æ–π –∫–æ–Ω—Ç–∞–∫—Ç–∞");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –≤ –æ–∂–∏–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞ —Ç–æ–∂–µ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º—É –ø–æ–∫–∞–∑—É –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã.
     */
    @Test
    void shouldRepeatContactRequestForEmptyTextWhileAwaitingContact() throws Exception {
        Long chatId = 323L;
        markAwaitingContact(chatId);

        Update update = mockTextUpdate(chatId, "   ");

        bot.consume(update);

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient).execute(captor.capture());
        SendMessage message = captor.getValue();

        assertEquals(chatId.toString(), message.getChatId());
        assertPhoneKeyboard(message.getReplyMarkup());
        assertTrue(message.getText().contains("–∫–Ω–æ–ø–∫"),
                "–ë–æ—Ç –¥–æ–ª–∂–µ–Ω –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É –∑–∞–ø—Ä–æ—Å–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞");
    }

    /**
     * –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –±–æ—Ç –æ—Ç–∫–ª–æ–Ω—è–µ—Ç –∫–æ–Ω—Ç–∞–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.
     */
    @Test
    void shouldRejectContactFromAnotherUser() throws Exception {
        Long chatId = 987L;
        markAwaitingContact(chatId);

        Update update = mockContactUpdate(chatId, 1_000_000_001L, 2_000_000_002L, "+375291234567");

        bot.consume(update);

        verify(telegramService, never()).linkTelegramToCustomer(anyString(), eq(chatId));

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient).execute(captor.capture());
        SendMessage response = captor.getValue();

        assertEquals(chatId.toString(), response.getChatId());
        assertTrue(response.getText().contains("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å, —á—Ç–æ –Ω–æ–º–µ—Ä –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º"));
        assertPhoneKeyboard(response.getReplyMarkup());
        assertEquals(BuyerChatState.AWAITING_CONTACT, bot.getState(chatId),
                "–ü–æ—Å–ª–µ –æ—Ç–∫–∞–∑–∞ –±–æ—Ç –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –æ–∂–∏–¥–∞—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç");
    }

    /**
     * –£–±–µ–∂–¥–∞–µ—Ç—Å—è, —á—Ç–æ —Å–ª—É–∂–µ–±–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ Telegram —Å–æ —Å–∫—Ä—ã—Ç–∏–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Å—Å–∏–∏.
     */
    @Test
    void shouldMarkKeyboardHiddenWhenReplyMarkupRequestsRemoval() throws Exception {
        Long chatId = 555L;

        Update update = serviceReplyUpdate(chatId, createRemoveKeyboardMarkup());

        bot.consume(update);

        assertTrue(chatSessionRepository.isKeyboardHidden(chatId),
                "–ü–æ—Å–ª–µ —Å–æ–æ–±—â–µ–Ω–∏—è remove_keyboard –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–æ–ª–∂–Ω–∞ —Å—á–∏—Ç–∞—Ç—å—Å—è —Å–∫—Ä—ã—Ç–æ–π");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –Ω–∞–ª–∏—á–∏–µ –æ–±—ã—á–Ω–æ–π inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∫—Ä—ã—Ç–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã.
     */
    @Test
    void shouldIgnoreInlineKeyboardWhileDetectingPersistentRemoval() throws Exception {
        Long chatId = 556L;

        Update update = serviceReplyUpdate(chatId, createInlineKeyboardMarkup());

        bot.consume(update);

        assertFalse(chatSessionRepository.isKeyboardHidden(chatId),
                "–°–æ–æ–±—â–µ–Ω–∏–µ —Å inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–∫—Ä—ã–≤–∞—Ç—å –ø–æ—Å—Ç–æ—è–Ω–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø–æ—Å–ª–µ —Å–æ–±—ã—Ç–∏—è my_chat_member –±–æ—Ç –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é —Å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π.
     */
    @Test
    void shouldRestorePersistentKeyboardWhenMyChatMemberArrives() throws Exception {
        Long chatId = 558L;
        Customer customer = new Customer();
        customer.setTelegramChatId(chatId);
        when(telegramService.findByChatId(chatId)).thenReturn(Optional.of(customer));

        Update update = mockMyChatMemberUpdate(chatId);

        bot.consume(update);

        assertEquals(BuyerChatState.IDLE, bot.getState(chatId),
                "–ü—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–π –ø–æ–∫—É–ø–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥");

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient, atLeastOnce()).execute(captor.capture());

        boolean hasPersistentKeyboard = captor.getAllValues().stream()
                .map(SendMessage::getReplyMarkup)
                .filter(ReplyKeyboardMarkup.class::isInstance)
                .map(ReplyKeyboardMarkup.class::cast)
                .anyMatch(this::keyboardContainsMenuButton);

        assertTrue(hasPersistentKeyboard,
                "–ü–æ—Å–ª–µ –≤–æ–∑–≤—Ä–∞—Ç–∞ –±–æ—Ç–∞ –≤ —á–∞—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–æ–π ¬´üè† –ú–µ–Ω—é¬ª –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–µ—Ä–µ–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏ ¬´üè† –ú–µ–Ω—é¬ª –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –æ–∂–∏–¥–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥
     * –ø—Ä–∏–≤–æ–¥–∏—Ç –ª–∏—à—å –∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—é —è–∫–æ—Ä–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ.
     */
    @Test
    void shouldNotSendKeyboardHintWhenMenuPressedTwiceInIdleState() throws Exception {
        Long chatId = 559L;
        Customer customer = new Customer();
        customer.setTelegramChatId(chatId);
        customer.setNotificationsEnabled(true);
        when(telegramService.findByChatId(chatId)).thenReturn(Optional.of(customer));

        ChatSession session = new ChatSession(chatId,
                BuyerChatState.IDLE,
                101,
                BuyerBotScreen.MENU,
                false,
                false);
        chatSessionRepository.save(session);

        Update update = mockTextUpdate(chatId, MENU_BUTTON_TEXT);

        bot.consume(update);

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient, times(1)).execute(captor.capture());

        SendMessage message = captor.getValue();
        assertEquals(chatId.toString(), message.getChatId(),
                "–û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –∏—Å—Ö–æ–¥–Ω—ã–π —á–∞—Ç");
        assertNotNull(message.getText(), "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–µ—Ä–µ–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ");
        assertTrue(message.getText().contains("üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
                "–ü–µ—Ä–µ–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–µ–∫—Å—Ç –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é");
    }

    /**
     * –£–±–µ–∂–¥–∞–µ—Ç—Å—è, —á—Ç–æ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤ Telegram –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–∏–≤—è–∑–∞—Ç—å –Ω–æ–º–µ—Ä.
     *
     * @param senderId      –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è –∏–ª–∏ {@code null}
     * @param contactUserId –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞ –∏–ª–∏ {@code null}
     * @param reason        –ø–æ—è—Å–Ω–µ–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏—è –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–µ
     */
    @ParameterizedTest
    @MethodSource("missingOwnershipIdentifiers")
    void shouldRejectContactWhenOwnershipIdentifiersMissing(Long senderId,
                                                            Long contactUserId,
                                                            String reason) throws Exception {
        Long chatId = 654L;
        markAwaitingContact(chatId);

        Update update = mockContactUpdate(chatId, senderId, contactUserId, "+375291234567");

        bot.consume(update);

        verify(telegramService, never()).linkTelegramToCustomer(anyString(), eq(chatId));

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient).execute(captor.capture());
        SendMessage response = captor.getValue();

        assertTrue(response.getText().contains("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å, —á—Ç–æ –Ω–æ–º–µ—Ä –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º"),
                () -> "–ü—Ä–∏ —Å—Ü–µ–Ω–∞—Ä–∏–∏ '" + reason + "' –±–æ—Ç –æ–±—è–∑–∞–Ω –ø–æ–≤—Ç–æ—Ä–Ω–æ –∑–∞–ø—Ä–æ—Å–∏—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ");
        assertPhoneKeyboard(response.getReplyMarkup());
        assertEquals(BuyerChatState.AWAITING_CONTACT, bot.getState(chatId),
                "–ü–æ—Å–ª–µ –æ—Ç–∫–∞–∑–∞ –±–æ—Ç –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –æ–∂–∏–¥–∞—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –∫–æ–º–∞–Ω–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–º–µ–Ω–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏.
     */
    @Test
    void shouldSendSuccessMessageWhenConfirmingNameFromMenu() throws Exception {
        Long chatId = 789L;
        when(telegramService.confirmName(chatId)).thenReturn(true);

        Update update = mockTextUpdate(chatId, "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏–º—è");

        bot.consume(update);

        verify(telegramService).confirmName(chatId);

        ArgumentCaptor<SendMessage> captor = ArgumentCaptor.forClass(SendMessage.class);
        verify(telegramClient, atLeastOnce()).execute(captor.capture());

        boolean hasSuccess = captor.getAllValues().stream()
                .map(SendMessage::getText)
                .filter(Objects::nonNull)
                .anyMatch(text -> text.contains("–¥–∞–Ω–Ω—ã–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω—ã"));

        assertTrue(hasSuccess, "–ë–æ—Ç –æ–±—è–∑–∞–Ω —É–≤–µ–¥–æ–º–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–± —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏");
    }

    /**
     * –ù–∞–±–æ—Ä –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–µ–º—ã—Ö —Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –∏ –æ–∂–∏–¥–∞–µ–º—ã—Ö –º–∞—Å–æ–∫.
     *
     * @return –ø–æ—Ç–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞
     */
    private static Stream<Arguments> recognizedPhones() {
        return Stream.of(
                "+375291234567",
                "80291234567",
                "8 029 123 45 67"
        ).map(number -> Arguments.of(number,
                PhoneUtils.maskPhone(PhoneUtils.normalizePhone(number))));
    }

    /**
     * –ù–∞–±–æ—Ä —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–æ–Ω—Ç–∞–∫—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.
     *
     * @return –ø–æ—Ç–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Å –∫–æ–º–±–∏–Ω–∞—Ü–∏—è–º–∏ senderId/contactUserId
     */
    private static Stream<Arguments> missingOwnershipIdentifiers() {
        return Stream.of(
                Arguments.of(null, 2_000_000_002L, "–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è"),
                Arguments.of(1_000_000_001L, null, "–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞"),
                Arguments.of(null, null, "–æ–±–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç")
        );
    }

    /**
     * –°–æ–∑–¥–∞—ë—Ç –º–æ–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è Telegram —Å —Ç–µ–∫—Å—Ç–æ–≤—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
     *
     * @param chatId –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞
     * @param text   —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
     * @return –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç {@link Update}
     */
    private Update mockTextUpdate(Long chatId, String text) {
        Update update = mock(Update.class);
        Message message = mock(Message.class);

        when(update.hasMessage()).thenReturn(true);
        when(update.getMessage()).thenReturn(message);
        when(message.hasText()).thenReturn(true);
        when(message.getText()).thenReturn(text);
        when(message.getChatId()).thenReturn(chatId);
        when(message.hasContact()).thenReturn(false);

        return update;
    }

    /**
     * –°–æ–∑–¥–∞—ë—Ç –º–æ–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è Telegram —Å –∫–æ–Ω—Ç–∞–∫—Ç–æ–º –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–æ–º–µ—Ä–æ–≤.
     *
     * @param chatId         –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞ Telegram
     * @param senderUserId   –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è
     * @param contactUserId  –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞
     * @param phoneNumber    –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞, —É–∫–∞–∑–∞–Ω–Ω—ã–π –≤ –∫–æ–Ω—Ç–∞–∫—Ç–µ
     * @return —Å–∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç {@link Update}
     */
    private Update mockContactUpdate(Long chatId,
                                     Long senderUserId,
                                     Long contactUserId,
                                     String phoneNumber) {
        Update update = mock(Update.class);
        Message message = mock(Message.class);
        Contact contact = mock(Contact.class);
        User fromUser = mock(User.class);

        when(update.hasMessage()).thenReturn(true);
        when(update.getMessage()).thenReturn(message);
        when(message.getChatId()).thenReturn(chatId);
        when(message.hasText()).thenReturn(false);
        when(message.hasContact()).thenReturn(true);
        when(message.getContact()).thenReturn(contact);
        when(message.getFrom()).thenReturn(fromUser);

        when(fromUser.getId()).thenReturn(senderUserId);
        when(contact.getUserId()).thenReturn(contactUserId);
        when(contact.getPhoneNumber()).thenReturn(phoneNumber);

        return update;
    }

    /**
     * –°–æ–∑–¥–∞—ë—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ Telegram —Ç–∏–ø–∞ my_chat_member –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã.
     *
     * @param chatId –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞ Telegram
     * @return —Å–∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç {@link Update}
     */
    private Update mockMyChatMemberUpdate(Long chatId) {
        Update update = mock(Update.class);
        ChatMemberUpdated myChatMember = mock(ChatMemberUpdated.class);
        Chat chat = mock(Chat.class);

        when(update.hasMyChatMember()).thenReturn(true);
        when(update.getMyChatMember()).thenReturn(myChatMember);
        when(myChatMember.getChat()).thenReturn(chat);
        when(chat.getId()).thenReturn(chatId);

        return update;
    }

    /**
     * –°–æ–∑–¥–∞—ë—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ Telegram —Å–æ —Å–ª—É–∂–µ–±–Ω—ã–º reply_markup.
     *
     * @param chatId      –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞ Telegram
     * @param replyMarkup —É–∑–µ–ª —Å –¥–∞–Ω–Ω—ã–º–∏ reply_markup
     * @return –æ–±—ä–µ–∫—Ç {@link Update} —Å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
     */
    private Update serviceReplyUpdate(Long chatId, ObjectNode replyMarkup) throws JsonProcessingException {
        ObjectNode root = objectMapper.createObjectNode();
        root.put("message_id", 1);
        root.put("date", 0);
        ObjectNode chat = root.putObject("chat");
        chat.put("id", chatId);
        chat.put("type", "private");
        root.set("reply_markup", replyMarkup);

        Message message = objectMapper.treeToValue(root, Message.class);

        Update update = new Update();
        update.setMessage(message);
        return update;
    }

    /**
     * –§–æ—Ä–º–∏—Ä—É–µ—Ç JSON-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã.
     *
     * @return —É–∑–µ–ª reply_markup —Å —Ñ–ª–∞–≥–æ–º remove_keyboard
     */
    private ObjectNode createRemoveKeyboardMarkup() {
        ObjectNode replyMarkup = objectMapper.createObjectNode();
        replyMarkup.put("remove_keyboard", true);
        return replyMarkup;
    }

    /**
     * –§–æ—Ä–º–∏—Ä—É–µ—Ç JSON inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è —Å–∫—Ä—ã—Ç–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã.
     *
     * @return —É–∑–µ–ª reply_markup —Å –æ–±—ã—á–Ω–æ–π inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
     */
    private ObjectNode createInlineKeyboardMarkup() {
        ObjectNode replyMarkup = objectMapper.createObjectNode();
        ArrayNode keyboard = replyMarkup.putArray("inline_keyboard");
        ArrayNode row = keyboard.addArray();
        ObjectNode button = row.addObject();
        button.put("text", "Demo");
        button.put("callback_data", "demo");
        return replyMarkup;
    }

    /**
     * –ü–æ–º–µ—á–∞–µ—Ç —á–∞—Ç –∫–∞–∫ –æ–∂–∏–¥–∞—é—â–∏–π –∫–æ–Ω—Ç–∞–∫—Ç–∞ —á–µ—Ä–µ–∑ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞.
     *
     * @param chatId –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞ Telegram
     */
    private void markAwaitingContact(Long chatId) throws Exception {
        chatSessionRepository.updateState(chatId, BuyerChatState.AWAITING_CONTACT);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–æ–π –∑–∞–ø—Ä–æ—Å–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞.
     *
     * @param replyKeyboard –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –±–æ—Ç–æ–º
     */
    private void assertPhoneKeyboard(ReplyKeyboard replyKeyboard) {
        assertNotNull(replyKeyboard, "–û–∂–∏–¥–∞–ª–∞—Å—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∑–∞–ø—Ä–æ—Å–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞");
        assertTrue(replyKeyboard instanceof ReplyKeyboardMarkup,
                "–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ç–∏–ø–∞ ReplyKeyboardMarkup");
        ReplyKeyboardMarkup markup = (ReplyKeyboardMarkup) replyKeyboard;
        List<KeyboardRow> rows = markup.getKeyboard();
        assertNotNull(rows);
        assertFalse(rows.isEmpty(), "–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É");

        boolean hasRequestContact = false;
        for (KeyboardRow row : rows) {
            for (KeyboardButton button : row) {
                if (Boolean.TRUE.equals(button.getRequestContact())) {
                    hasRequestContact = true;
                    break;
                }
            }
            if (hasRequestContact) {
                break;
            }
        }
        assertTrue(hasRequestContact, "–ö–Ω–æ–ø–∫–∞ —Å –∑–∞–ø—Ä–æ—Å–æ–º –∫–æ–Ω—Ç–∞–∫—Ç–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –∫–Ω–æ–ø–∫–∏ ¬´üè† –ú–µ–Ω—é¬ª –≤ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ.
     *
     * @param markup –ø—Ä–æ–≤–µ—Ä—è–µ–º–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
     * @return {@code true}, –µ—Å–ª–∏ –∫–Ω–æ–ø–∫–∞ –Ω–∞–π–¥–µ–Ω–∞
     */
    private boolean keyboardContainsMenuButton(ReplyKeyboardMarkup markup) {
        if (markup == null || markup.getKeyboard() == null) {
            return false;
        }

        return markup.getKeyboard().stream()
                .filter(Objects::nonNull)
                .flatMap(row -> row.stream().filter(Objects::nonNull))
                .map(KeyboardButton::getText)
                .anyMatch(MENU_BUTTON_TEXT::equals);
    }
}
